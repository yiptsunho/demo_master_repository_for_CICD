name: Main CI/CD
on:
  repository_dispatch:
    types: [module-updated]
  push:
    branches:
      - main
      - uat
    paths-ignore:
      - 'README.md'
      - 'TEST_STATUS.md'
      - '.github/workflows/cicd.yml'
concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  build-and-test:
    runs-on: ubuntu-latest
    env:
      SERVER_HOST: ${{ secrets.SERVER_HOST }}
      SERVER_PATH: ${{ secrets.SERVER_PATH }}
      TEST_REPO: ${{ secrets.TEST_REPO }}
      API_URL_PROD: ${{ secrets.API_URL_PROD }}
      API_URL_CI: ${{ secrets.API_URL_CI }}
      JUNIT_FILE_PATH: junit.xml
    steps:
      - name: Checkout Main Repository
        uses: actions/checkout@v4
        with:
          ref: main
      - name: Pull Latest Changes
        run: |
          git fetch origin
          git pull origin main --no-rebase --strategy-option=ours || {
            echo "Merge conflict detected, resolving by keeping local changes"
            git checkout --ours README.md TEST_STATUS.md
            git add README.md TEST_STATUS.md
            git commit -m "Resolve merge conflict during checkout by keeping local changes"
          }
      - name: Clean up uncommitted changes
        run: |
          git restore .
          git restore --staged .
          echo "Working directory and staging area cleaned"
      - name: Connect to integration instance
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts
          ssh root@${{ env.SERVER_HOST }} "cd ${{ env.SERVER_PATH }} && git status && git fetch origin && git reset --hard origin/main && git clean -fd && git pull origin main && git status"
        env:
          SSH_KEY: ${{ secrets.SSH_KEY }}
      - name: Checkout Test Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.TEST_REPO }}
          token: ${{ secrets.TEST_REPO_TOKEN }}
          path: test-repo
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install Test Dependencies
        run: |
          cd test-repo
          npm install
          npm install --save-dev jest-junit jest-github-actions-reporter
      - name: Run API Tests
        id: api-tests
        run: |
          cd test-repo
          npm test index; true
        env:
          # TODO: modify logic to change API_URL depending on whether it is integration instance or prd instance
          # API_URL: ${{ github.ref == 'refs/heads/main' && env.API_URL_PROD || env.API_URL_CI }}
          API_URL: ${{ env.API_URL_CI }}
      - name: Parse Test Results
        if: always()
        id: parse-results
        run: |
          cp test-repo/reports/junit.xml junit.xml
          sudo apt-get update && sudo apt-get install -y libxml2-utils jq
          if [ ! -f ${{ env.JUNIT_FILE_PATH }} ]; then
            echo "Error: ${{ env.JUNIT_FILE_PATH }} not found in workflow root"
            exit 1
          fi
          if [ ! -f module_mapping.json ]; then
            echo "Error: module_mapping.json not found"
            exit 1
          fi
          MODULES=$(xmllint --xpath '//testcase/@classname' ${{ env.JUNIT_FILE_PATH }} | grep -oE '[a-z_]+/[a-z_]+' | cut -d'/' -f1 | sort -u)
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M UTC")
          COMMIT="${{ github.event.client_payload.commit || github.sha }}"
          COMMIT_SHORT=$(echo "$COMMIT" | cut -c1-8)
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "# Test Results" > results.txt
          echo "" >> results.txt
          echo "## Latest Test Run ($TIMESTAMP)" >> results.txt
          echo "" >> results.txt
          echo "**Commit**: \`$COMMIT_SHORT\`" >> results.txt
          echo "**Run URL**: [$RUN_URL]($RUN_URL)" >> results.txt
          echo "" >> results.txt
          echo "| Module | Status |" >> results.txt
          echo "|--------|--------|" >> results.txt
          for module in $MODULES; do
            REPO=$(jq -r --arg mod "$module" '.[] | select(.module == $mod) | .repository' module_mapping.json)
            if [ -z "$REPO" ]; then
              echo "Warning: No repository mapping found for module $module"
              REPO="Unknown"
            fi
            FAILED=$(xmllint --xpath "count(//testcase[contains(@classname, '$module/')]/failure)" ${{ env.JUNIT_FILE_PATH }} 2>/dev/null || echo 0)
            STATUS=$([ "$FAILED" -eq 0 ] && echo "✅ Success" || echo "❌ Failure")
            echo "| $module | $STATUS |" >> results.txt
            echo "$module,$REPO,$STATUS,$COMMIT,$TIMESTAMP,$RUN_URL" >> results_history.txt
          done
          echo "" >> results.txt
          BADGE_COLOR=$([[ "${{ steps.api-tests.outcome }}" == "success" ]] && echo "green" || echo "red")
          echo "![Test Status](https://img.shields.io/badge/Test%20Status-${{ steps.api-tests.outcome }}-$BADGE_COLOR)" >> results.txt
          echo "results<<EOF" >> $GITHUB_OUTPUT
          cat results.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Update README.md
        if: always()
        run: |
          echo "# Main Repository Test Results" > README.md
          echo "" >> README.md
          cat results.txt >> README.md
      - name: Update TEST_STATUS.md
        if: always()
        run: |
          if [ ! -f TEST_STATUS.md ]; then
            echo "# Historical Test Results" > TEST_STATUS.md
            echo "" >> TEST_STATUS.md
            echo "| Module | Repository | Status | Commit | Timestamp | Run URL |" >> TEST_STATUS.md
            echo "|--------|------------|--------|--------|-----------|---------|" >> TEST_STATUS.md
          fi
          cat results_history.txt | while IFS=',' read -r module repo status commit timestamp run_url; do
            echo "| $module | $repo | $status | $commit | $timestamp | [$run_url]($run_url) |" >> TEST_STATUS.md
          done
      - name: Commit Updated Files
        if: always()
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git config pull.rebase false
          git add README.md TEST_STATUS.md
          git commit -m "Update test results for run ${{ github.run_id }}"
          git pull
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Notify Module Repositories
        if: always()
        run: |
          MODULES=$(xmllint --xpath '//testcase/@classname' ${{ env.JUNIT_FILE_PATH }} | grep -oE '[a-z_]+/[a-z_]+' | cut -d'/' -f1 | sort -u)
          for module in $MODULES; do
            REPO=$(jq -r --arg mod "$module" '.[] | select(.module == $mod) | .repository' module_mapping.json)
            if [ -z "$REPO" ]; then
              echo "Warning: No repository mapping found for module $module, skipping notification"
              continue
            fi
            FAILED=$(xmllint --xpath "count(//testcase[contains(@classname, '$module/')]/failure)" ${{ env.JUNIT_FILE_PATH }} 2>/dev/null || echo 0)
            STATUS=$([ "$FAILED" -eq 0 ] && echo "success" || echo "failure")
            curl -X POST \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer ${{ secrets.MODULE_REPO_TOKEN }}" \
              https://api.github.com/repos/$REPO/dispatches \
              -d "{\"event_type\":\"test-results\",\"client_payload\":{\"test_status\":\"$STATUS\",\"results_url\":\"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",\"commit\":\"${{ github.event.client_payload.commit || github.sha }}\",\"module\":\"$module\",\"repository\":\"$REPO\",\"module_repo_token\":\"${{ secrets.MODULE_REPO_TOKEN }}\"}}"
          done
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ${{ env.JUNIT_FILE_PATH }}
          retention-days: 7
      - name: Clean up uncommitted changes
        if: always()
        run: |
          git restore .
          git restore --staged .